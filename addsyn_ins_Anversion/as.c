/*  This file is generated by insdes.  DO NOT EDIT!
 *  Edit the template file instead (as.t).
 */
#include <stdio.h>
#include <math.h>
#include "muse.h"
#define ABORTNOTE return 1
#define ABORTSAMPLE { TacetNote(__PLIST); return; }

/* Score card structure definition */
typedef struct {
# line 6 "as.t"
	float _filename;
#define filename (ADDSYN_scor->_filename)
#define _insdesCheck_0_(x)
# line 7 "as.t"
	float _pch;
#define pch (ADDSYN_scor->_pch)
#define _insdesCheck_1_(x) if ((x) < 3.999999 || (x) > 12.000001) {printf("Parameter pch = %f out of range (4.000000, 12.000000)\n",x); return 1;}
# line 8 "as.t"
	float _ascale;
#define ascale (ADDSYN_scor->_ascale)
#define _insdesCheck_2_(x) if ((x) < 0.099999 || (x) > 10.000001) {printf("Parameter ascale = %f out of range (0.100000, 10.000000)\n",x); return 1;}
# line 9 "as.t"
	float _lfrac;
#define lfrac (ADDSYN_scor->_lfrac)
#define _insdesCheck_3_(x) if ((x) < -0.000001 || (x) > 1.000001) {printf("Parameter lfrac = %f out of range (0.000000, 1.000000)\n",x); return 1;}
	} ADDSYN_SCOR;

ADDSYN_SCOR *ADDSYN_scor;


/* Instrument structure definition */
typedef struct {
# line 11 "as.t"
	char *___PLIST;
#define __PLIST (ADDSYN_ins->___PLIST)
# line 12 "as.t"
	float _sifaci;
#define sifaci (ADDSYN_ins->_sifaci)
# line 12 "as.t"
	float _ascalei;
#define ascalei (ADDSYN_ins->_ascalei)
# line 12 "as.t"
	float _fai;
#define fai (ADDSYN_ins->_fai)
# line 12 "as.t"
	float *_cmagi;
#define cmagi (ADDSYN_ins->_cmagi)
# line 12 "as.t"
	float *_dfri;
#define dfri (ADDSYN_ins->_dfri)
# line 12 "as.t"
	float *_phasei;
#define phasei (ADDSYN_ins->_phasei)
# line 12 "as.t"
	float _dxi;
#define dxi (ADDSYN_ins->_dxi)
# line 12 "as.t"
	float _xi;
#define xi (ADDSYN_ins->_xi)
# line 12 "as.t"
	float _lfraci;
#define lfraci (ADDSYN_ins->_lfraci)
# line 13 "as.t"
	float _dti;
#define dti (ADDSYN_ins->_dti)
# line 13 "as.t"
	float _tli;
#define tli (ADDSYN_ins->_tli)
# line 13 "as.t"
	float _nptsi;
#define nptsi (ADDSYN_ins->_nptsi)
# line 14 "as.t"
	int _nhar1i;
#define nhar1i (ADDSYN_ins->_nhar1i)
# line 14 "as.t"
	int _fptri;
#define fptri (ADDSYN_ins->_fptri)
# line 14 "as.t"
	int _itrap;
#define itrap (ADDSYN_ins->_itrap)
# line 14 "as.t"
	int _inoteno;
#define inoteno (ADDSYN_ins->_inoteno)
	} ADDSYN_INS;

/* Constants, macros, and globals */
# line 17 "as.t"
extern int nhar1, npts;
extern float fa, *phas0, *cmag, *dfr;
#include <strings.h>
#include "anread.c"
#include "addsynfunc.c"

/* Note-time instr. setup */

int ADDSYN_note(ADDSYN_ins)
ADDSYN_INS *ADDSYN_ins;
{
	_insdesCheck_0_(((float *)ADDSYN_scor)[0]);
	_insdesCheck_1_(((float *)ADDSYN_scor)[1]);
	_insdesCheck_2_(((float *)ADDSYN_scor)[2]);
	_insdesCheck_3_(((float *)ADDSYN_scor)[3]);
{
# line 24 "as.t"
int k;
float freq, fac, OFF;
char *anFile = GetScorecardString(filename);

fptri = anread(anFile);
if(fptri == -1)
{
    P("Can not open file %s. Abort job.\n",anFile);
    exit(-1);
}
P("\nAdd syn of file %s at start_time = %.3f, duration = %.3f\n",
    anFile,STIME,DUR);
P("pitch = %.3f, ampscale= %.3f\n", pch, ascale); fflush(stdout);

freq = cpspitch(pch);
ascalei = ascale;
sifaci = (FFUN_LEN/SR)*(freq/fa);    /* provides frequency scaling */
phasei = (float *) malloc(nhar1 * sizeof(float));
fac = FFUN_LEN/(8. * atan(1)); OFF = .25 * FFUN_LEN;
for (k = 1; k < nhar1; k++) {
    phasei[k] = OFF + fac * phas0[k];
}
/* provides time-scaling: */

//start to Modify
float origDur = tl;
P("original sound duration is %.3f sec:\n", origDur);
// increment for traversing the cmagi and dfri data
P("pt1\n");
fflush(stdout);
dxi = (npts - 1) / ((float) origDur * SR);
P("pt2\n");
fflush(stdout);
calcRMS(cmag);
P("pt3\n");
fflush(stdout);
int attackf, decayf;
P("pt4\n");
fflush(stdout);
findattackdecay(&attackf, &decayf);
P("pt5\n");
fflush(stdout);

float attackt = attackf * dt;
float decayt = decayf * dt;
P("pt6\n");
fflush(stdout);
P("dt is %f\n", dt);
P("attackt is %f and decayt is %f\n", attackt, decayt);
fflush(stdout);

float totalt, extendt;
totalt = DUR;
int ratio;
float minimumT = attackt + (origDur - decayt);
P("minimum duration is %.3f\n", minimumT);
P("pt7\n");
fflush(stdout);

cmagi = cmag;
dfri = dfr;

//extend
if (DUR > origDur)
{
    decayf = decayf - (decayf - attackf) * 0.3;
    attackf = attackf + (decayf - attackf) * 0.3;
    float mduration = (decayf - attackf) * dt;
    P("mduration is %f\n", mduration);
    fflush(stdout);
    extendt = totalt - origDur;
    P("extendt is %f\n", extendt);
    fflush(stdout);
    ratio = extendt / mduration;
    P("ratio is %d\n",ratio);
    fflush(stdout);
    extendsyn(&cmagi, &dfri, nhar1, DUR, extendt, ratio);
    P("the extension is done\n");
}
//shorten
else if (DUR < origDur)
{
    if (DUR < minimumT) // timescale compressed attack+decay
    {
        timescalemin(&cmagi, &dfri, nhar1, DUR, minimumT, origDur);
    }
    else
    {
        reddursyn(&cmagi, &dfri, nhar1, DUR, origDur);
    }
}
// do nothing if DUR = origDur

dxi = (npts - 1) / ((float) DUR * SR);
printf("dxi: %f\n", dxi);

/* save parameters for sample comp */
fai = fa;
nhar1i = nhar1;
nptsi = npts;
dti = dt;
tli = tl;
xi = 0.;
lfraci = lfrac;
itrap = 0;
inoteno++;
P("Complete addsyn setup\n");
fflush(stdout);
}
	return 0;
}

/* End-of-note instrument cleanup */
int ADDSYN_endnote(ADDSYN_ins)
ADDSYN_INS *ADDSYN_ins;
{
# line 134 "as.t"
free(phasei);
}

/* Sample-time instrument output */

void ADDSYN_samp(ADDSYN_ins)
ADDSYN_INS *ADDSYN_ins;
{
# line 137 "as.t"
int i, k, narg1, narg2, iphasek;
float sum, w1,w2,x1,x2, phasek, ampk;
// if(itrap==0)
// {
//     P("in .sample, noteno = %d\n", inoteno);
// }
// if (i>2170)
// {
//     P("i is %d\n",i);
// }
// if(i >= npts)
// {
//   P("i is greater then npts, it is going to crash\n");
// }
//   compute interpolation weights from current xi
i = xi; w2 = xi - i; w1 = 1.0 - w2;
if ((i + 1) < nptsi)
{
    narg1 = i * nhar1i;
    narg2 = (i + 1) * nhar1i;
    sum = 0;                /* add up to form sample value sum */
    for (k = 1; k < nhar1i; k++)
    {
        /* compute Sine table lookup phase for each harmonic */
        phasek = phasei[k];
        phasek += sifaci * (k * fai + w1 * dfri[narg1 + k] + w2 * dfri[narg2 + k]);
        phasek = amod(phasek, FFUN_LEN);
        if (phasek < 0.) phasek += FFUN_LEN;
        // save phase for next sample
        phasei[k] = phasek;
        iphasek = phasek; x2 = phasek - iphasek; x1 = 1.0 - x2;
        ampk = w1*cmagi[narg1 + k] + w2*cmagi[narg2 + k];
        sum += ampk*(x1*Sine[iphasek] + x2*Sine[iphasek +1]);
    }
}
else sum = 0.;
NoQuad(ascalei * sum, lfraci);        /* output sample */
xi += dxi;                /* update an array lookup index */
}
/* The instrument init routine */
void ADDSYN_init(name,maxv)
char *name;
int maxv;
{
	ADDSYN_INS *ADDSYN_ip;
	ADDSYN_ip = maptyp(name,maxv,ADDSYN_INS,ADDSYN_note,ADDSYN_samp,ADDSYN_endnote);
	ADDSYN_scor = Istencil(ADDSYN_SCOR,0);
}
